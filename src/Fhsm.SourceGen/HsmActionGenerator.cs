using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Fhsm.SourceGen
{
    [Generator]
    public class HsmActionGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // Find all methods with [HsmAction] or [HsmGuard]
            var actionMethods = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => IsCandidateMethod(s),
                    transform: static (ctx, _) => GetMethodInfo(ctx))
                .Where(static m => m != null);

            // Collect and generate
            var compilationAndMethods = context.CompilationProvider.Combine(actionMethods.Collect());

            context.RegisterSourceOutput(
                compilationAndMethods,
                static (spc, source) => Execute(spc, source.Left, source.Right));
        }

        private static bool IsCandidateMethod(SyntaxNode node)
        {
            return node is MethodDeclarationSyntax method &&
                   method.AttributeLists.Count > 0;
        }

        private static MethodInfo? GetMethodInfo(GeneratorSyntaxContext context)
        {
            var method = (MethodDeclarationSyntax)context.Node;
            var symbol = context.SemanticModel.GetDeclaredSymbol(method);
            
            if (symbol == null) return null;

            // Check for [HsmAction] or [HsmGuard]
            var actionAttr = symbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "HsmActionAttribute");
            var guardAttr = symbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "HsmGuardAttribute");

            if (actionAttr == null && guardAttr == null) return null;

            var isGuard = guardAttr != null;
            var attr = isGuard ? guardAttr : actionAttr;

            // Get name (from attribute or method name)
            string name = symbol.Name;
            var nameArg = attr!.NamedArguments.FirstOrDefault(a => a.Key == "Name");
            if (nameArg.Value.Value is string customName && !string.IsNullOrEmpty(customName))
            {
                name = customName;
            }

            return new MethodInfo
            {
                Name = name,
                FullName = $"{symbol.ContainingType.ToDisplayString()}.{symbol.Name}",
                IsGuard = isGuard,
                IsStatic = symbol.IsStatic
            };
        }

        private static void Execute(SourceProductionContext context, Compilation compilation, IEnumerable<MethodInfo> methods)
        {
            var actions = methods.Where(m => !m.IsGuard).ToList();
            var guards = methods.Where(m => m.IsGuard).ToList();
            
            string assemblyName = compilation.AssemblyName ?? "Fhsm.Kernel";
            bool isKernel = assemblyName == "Fhsm.Kernel";

            if (isKernel)
            {
                // Generate the central Dispatcher in Kernel
                var source = GenerateKernelDispatcher(actions, guards, "Fhsm.Kernel");
                context.AddSource("HsmActionDispatcher.g.cs", source);
            }
            else
            {
                // Generate a Registrar in User Assembly
                string namespaceName = $"{assemblyName}.Generated";
                var source = GenerateRegistrar(actions, guards, namespaceName);
                context.AddSource("HsmActionRegistrar.g.cs", source);
            }
        }

        private static string GenerateKernelDispatcher(List<MethodInfo> actions, List<MethodInfo> guards, string namespaceName)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.AppendLine("    public static unsafe class HsmActionDispatcher");
            sb.AppendLine("    {");
            
            // Action table
            sb.AppendLine("        private static readonly Dictionary<ushort, IntPtr> ActionTable = new()");
            sb.AppendLine("        {");
            foreach (var action in actions)
            {
                ushort id = ComputeHash(action.Name);
                sb.AppendLine($"            {{ {id}, (IntPtr)(delegate* <void*, void*, ushort, void>)&{action.FullName} }},");
            }
            sb.AppendLine("        };");
            sb.AppendLine();

            // Guard table
            sb.AppendLine("        private static readonly Dictionary<ushort, IntPtr> GuardTable = new()");
            sb.AppendLine("        {");
            foreach (var guard in guards)
            {
                ushort id = ComputeHash(guard.Name);
                sb.AppendLine($"            {{ {id}, (IntPtr)(delegate* <void*, void*, ushort, bool>)&{guard.FullName} }},");
            }
            sb.AppendLine("        };");
            sb.AppendLine();

            // Dispatch methods
            sb.AppendLine("        public static void ExecuteAction(ushort actionId, void* instance, void* context, ushort eventId)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (ActionTable.TryGetValue(actionId, out var actionPtr))");
            sb.AppendLine("            {");
            sb.AppendLine("                ((delegate* <void*, void*, ushort, void>)actionPtr)(instance, context, eventId);");
            sb.AppendLine("            }");
            sb.AppendLine("        }");
            sb.AppendLine();

            sb.AppendLine("        public static bool EvaluateGuard(ushort guardId, void* instance, void* context, ushort eventId)");
            sb.AppendLine("        {");
            sb.AppendLine("            if (GuardTable.TryGetValue(guardId, out var guardPtr))");
            sb.AppendLine("            {");
            sb.AppendLine("                return ((delegate* <void*, void*, ushort, bool>)guardPtr)(instance, context, eventId);");
            sb.AppendLine("            }");
            sb.AppendLine("            return true; // No guard = always pass");
            sb.AppendLine("        }");
            sb.AppendLine();
            
            // Registration
            sb.AppendLine("        public static void RegisterAction(ushort id, IntPtr action) => ActionTable[id] = action;");
            sb.AppendLine("        public static void RegisterGuard(ushort id, IntPtr guard) => GuardTable[id] = guard;");
            
            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static string GenerateRegistrar(List<MethodInfo> actions, List<MethodInfo> guards, string namespaceName)
        {
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("using System;");
            sb.AppendLine("using Fhsm.Kernel;");
            sb.AppendLine();
            sb.AppendLine($"namespace {namespaceName}");
            sb.AppendLine("{");
            sb.AppendLine("    public static unsafe class HsmActionRegistrar");
            sb.AppendLine("    {");
            sb.AppendLine("        public static void RegisterAll()");
            sb.AppendLine("        {");
            
            foreach (var action in actions)
            {
                ushort id = ComputeHash(action.Name);
                sb.AppendLine($"            HsmActionDispatcher.RegisterAction({id}, (IntPtr)(delegate* <void*, void*, ushort, void>)&{action.FullName});");
            }

            foreach (var guard in guards)
            {
                ushort id = ComputeHash(guard.Name);
                sb.AppendLine($"            HsmActionDispatcher.RegisterGuard({id}, (IntPtr)(delegate* <void*, void*, ushort, bool>)&{guard.FullName});");
            }
            
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine("}");
            return sb.ToString();
        }

        private static ushort ComputeHash(string name)
        {
            // Simple hash (FNV-1a)
            uint hash = 2166136261;
            foreach (char c in name)
            {
                hash ^= c;
                hash *= 16777619;
            }
            return (ushort)(hash & 0xFFFF);
        }

        private class MethodInfo
        {
            public string Name { get; set; } = "";
            public string FullName { get; set; } = "";
            public bool IsGuard { get; set; }
            public bool IsStatic { get; set; }
        }
    }
}
